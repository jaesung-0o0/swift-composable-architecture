{"schemaVersion":{"major":0,"patch":0,"minor":3},"primaryContentSections":[{"declarations":[{"tokens":[{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"fireAndForget"},{"text":": ","kind":"text"},{"text":"FireAndForget","kind":"typeIdentifier","preciseIdentifier":"s:12Dependencies13FireAndForgetV","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/FireAndForget"},{"text":" { ","kind":"text"},{"text":"get","kind":"keyword"},{"kind":"text","text":" "},{"text":"set","kind":"keyword"},{"text":" }","kind":"text"}],"languages":["swift"],"platforms":["iOS"]}],"kind":"declarations"},{"content":[{"level":2,"type":"heading","text":"Discussion","anchor":"discussion"},{"inlineContent":[{"text":"Useful as a controllable and testable substitute for a ","type":"text"},{"code":"Task { }","type":"codeVoice"},{"type":"text","text":" that performs some work off"},{"type":"text","text":" "},{"type":"text","text":"into the void. In tests, the operation becomes structured, and the async context that kicks"},{"text":" ","type":"text"},{"text":"off the work will wait for it to complete before resuming.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you are building a server application that has an endpoint for updating"},{"text":" ","type":"text"},{"type":"text","text":"a user’s email address. To accomplish that you will first make a database request to update"},{"type":"text","text":" "},{"text":"the user’s email, and then if that succeeds you will send an email to the new address to let","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the user know their email has been updated."}]},{"type":"paragraph","inlineContent":[{"text":"However, there is no need to tie up the server in order to send the email. That request","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"doesn’t return any data of interest, and we just want to fire it off and then forget about it."},{"text":" ","type":"text"},{"text":"One way to do this is to use an unstructured ","type":"text"},{"code":"Task","type":"codeVoice"},{"text":" like so:","type":"text"}]},{"syntax":"swift","code":["try await self.database.updateUser(id: userID, email: newEmailAddress)","Task {","  try await self.sendEmail(","    email: newEmailAddress,","    subject: \"Your email has been updated\"","  )","}"],"type":"codeListing"},{"inlineContent":[{"text":"However, this kind of code can be problematic for testing. In a test we would like to verify","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that an email is sent, but the code inside the "},{"code":"Task","type":"codeVoice"},{"text":" is executed at some later time. We","type":"text"},{"type":"text","text":" "},{"type":"text","text":"would need to add "},{"type":"codeVoice","code":"Task.sleep"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"Task.yield"},{"type":"text","text":" to the test to give the task enough time to"},{"type":"text","text":" "},{"text":"start and finish, which can be flakey and error prone.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So, instead, you can use the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyValues\/fireAndForget"},{"type":"text","text":" dependency, which creates an unstructured task"},{"text":" ","type":"text"},{"text":"when run in production, but creates a ","type":"text"},{"inlineContent":[{"type":"text","text":"structured"}],"type":"emphasis"},{"type":"text","text":" task in tests:"}],"type":"paragraph"},{"syntax":"swift","code":["try await self.database.updateUser(id: userID, email: newEmailAddress)","await self.fireAndForget {","  try await self.sendEmail(","    email: newEmailAddress,","    subject: \"You email has been updated\"","  )","}"],"type":"codeListing"},{"inlineContent":[{"text":"Now this is easy to test. We just have to ","type":"text"},{"type":"codeVoice","code":"await"},{"type":"text","text":" for the code to finish, and once it does"},{"type":"text","text":" "},{"text":"we can verify that the email was sent.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyValues\/fireAndForget"},"metadata":{"title":"fireAndForget","externalID":"s:12Dependencies16DependencyValuesV13fireAndForgetAA04FireeF0Vvp","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"fireAndForget"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:12Dependencies13FireAndForgetV","text":"FireAndForget"}],"symbolKind":"property","modules":[{"name":"ComposableArchitecture","relatedModules":["Dependencies"]}],"roleHeading":"Instance Property","extendedModule":"Dependencies","role":"symbol"},"kind":"symbol","sections":[],"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyValues"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/composablearchitecture\/dependencyvalues\/fireandforget"]}],"abstract":[{"text":"A dependency for firing off an unstructured task.","type":"text"}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyValues":{"url":"\/documentation\/composablearchitecture\/dependencyvalues","navigatorTitle":[{"text":"DependencyValues","kind":"identifier"}],"kind":"symbol","abstract":[{"text":"A collection of dependencies that is globally available.","type":"text"}],"role":"symbol","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyValues","title":"DependencyValues","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"DependencyValues"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","role":"collection","url":"\/documentation\/composablearchitecture","abstract":[{"text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"type":"topic","kind":"symbol","title":"ComposableArchitecture"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/FireAndForget":{"role":"symbol","type":"topic","abstract":[{"text":"A type for creating unstructured tasks in production and structured tasks in tests.","type":"text"}],"url":"\/documentation\/composablearchitecture\/fireandforget","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/FireAndForget","title":"FireAndForget","kind":"symbol","navigatorTitle":[{"text":"FireAndForget","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"FireAndForget","kind":"identifier"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyValues/fireAndForget":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyValues\/fireAndForget","role":"symbol","url":"\/documentation\/composablearchitecture\/dependencyvalues\/fireandforget","fragments":[{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"fireAndForget"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"FireAndForget","preciseIdentifier":"s:12Dependencies13FireAndForgetV"}],"abstract":[{"text":"A dependency for firing off an unstructured task.","type":"text"}],"type":"topic","kind":"symbol","title":"fireAndForget"}}}