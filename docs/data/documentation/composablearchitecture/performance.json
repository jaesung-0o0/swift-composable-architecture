{"schemaVersion":{"patch":0,"minor":3,"major":0},"sections":[],"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"seeAlsoSections":[{"identifiers":["doc:\/\/ComposableArchitecture\/tutorials\/MeetComposableArchitecture","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation"],"generated":true,"title":"Essentials"}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"type":"heading","level":2,"anchor":"overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"As your features and application grow you may run into performance problems, such as reducers","type":"text"},{"text":" ","type":"text"},{"text":"becoming slow to execute, SwiftUI view bodies executing more often than expected, and more. This","type":"text"},{"type":"text","text":" "},{"text":"article outlines a few common pitfalls when developing features in the library, and how to fix","type":"text"},{"type":"text","text":" "},{"type":"text","text":"them."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"identifier":"#View-stores","type":"reference","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#Sharing-logic-with-actions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"#CPU-intensive-calculations","type":"reference"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"#High-frequency-actions","type":"reference","isActive":true}]}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"#Compiler-performance"}],"type":"paragraph"}]}]},{"anchor":"View-stores","type":"heading","level":3,"text":"View stores"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A common performance pitfall when using the library comes from constructing "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore"},{"type":"text","text":"s, which"},{"text":" ","type":"text"},{"type":"text","text":"is the object that observes changes to your feature’s state. When constructed naively, using either"},{"type":"text","text":" "},{"type":"text","text":"view store’s initializer "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore\/init(_:observe:)-3ak1y","isActive":true},{"text":" or the SwiftUI helper","type":"text"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore"},{"type":"text","text":", it  will observe every change to state in the store:"}]},{"type":"codeListing","syntax":"swift","code":["WithViewStore(self.store, observe: { $0 }) { viewStore in ","  \/\/ This is executed for every action sent into the system ","  \/\/ that causes self.store.state to change. ","}"]},{"inlineContent":[{"type":"text","text":"Most of the time this observes far too much state. A typical feature in the Composable Architecture"},{"type":"text","text":" "},{"text":"holds onto not only the state the view needs to present UI, but also state that the feature only","type":"text"},{"text":" ","type":"text"},{"text":"needs internally, as well as state of child features embedded in the feature. Changes to the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"internal and child state should not cause the view’s body to re-compute since that state is not"},{"type":"text","text":" "},{"type":"text","text":"needed in the view."}],"type":"paragraph"},{"inlineContent":[{"text":"For example, if the root of our application was a tab view, then we could model that in state as a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"struct that holds each tab’s state as a property:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct AppFeature: Reducer {","  struct State {","    var activity: Activity.State","    var search: Search.State","    var profile: Profile.State","  }","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"text":"If the view only needs to construct the views for each tab, then no view store is even needed","type":"text"},{"text":" ","type":"text"},{"text":"because we can pass scoped stores to each child feature view:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct AppView: View {","  let store: StoreOf<AppFeature>","","  var body: some View {","    \/\/ No need to observe state changes because the view does","    \/\/ not need access to the state.","","    TabView {","      ActivityView(","        store: self.store","          .scope(state: \\.activity, action: { .activity($0) })","      )","      SearchView(","        store: self.store","          .scope(state: \\.search, action: { .search($0) })","      )","      ProfileView(","        store: self.store","          .scope(state: \\.profile, action: { .profile($0) })","      )","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"This means ","type":"text"},{"type":"codeVoice","code":"AppView"},{"type":"text","text":" does not actually need to observe any state changes. This view will only be"},{"text":" ","type":"text"},{"type":"text","text":"created a single time, whereas if we observed the store then it would re-compute every time a single"},{"type":"text","text":" "},{"text":"thing changed in either the activity, search or profile child features.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If sometime in the future we do actually need some state from the store, we can start to observe"},{"text":" ","type":"text"},{"type":"text","text":"only the bare essentials of state necessary for the view to do its job. For example, suppose that"},{"type":"text","text":" "},{"type":"text","text":"we need access to the currently selected tab in state:"}]},{"type":"codeListing","code":["struct AppFeature: Reducer {","  enum Tab { case activity, search, profile }","  struct State {","    var activity: Activity.State","    var search: Search.State","    var profile: Profile.State","    var selectedTab: Tab","  }","  \/\/ ...","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Then we can observe this state so that we can construct a binding to "},{"type":"codeVoice","code":"selectedTab"},{"type":"text","text":" for the tab view:"}],"type":"paragraph"},{"code":["struct AppView: View {","  let store: StoreOf<AppFeature>","","  var body: some View {","    WithViewStore(self.store, observe: { $0 }) { viewStore in","      TabView(","        selection: viewStore.binding(get: \\.selectedTab, send: { .tabSelected($0) })","      ) {","        ActivityView(","          store: self.store.scope(state: \\.activity, action: { .activity($0) })","        )","        .tag(AppFeature.Tab.activity)","        SearchView(","          store: self.store.scope(state: \\.search, action: { .search($0) })","        )","        .tag(AppFeature.Tab.search)","        ProfileView(","          store: self.store.scope(state: \\.profile, action: { .profile($0) })","        )","        .tag(AppFeature.Tab.profile)","      }","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, this style of state observation is terribly inefficient since "},{"type":"emphasis","inlineContent":[{"type":"text","text":"every"}]},{"type":"text","text":" change to"},{"text":" ","type":"text"},{"code":"AppFeature.State","type":"codeVoice"},{"text":" will cause the view to re-compute even though the only piece of state we actually","type":"text"},{"text":" ","type":"text"},{"text":"care about is the ","type":"text"},{"type":"codeVoice","code":"selectedTab"},{"text":". The reason we are observing too much state is because we use","type":"text"},{"type":"text","text":" "},{"code":"observe: { $0 }","type":"codeVoice"},{"type":"text","text":" in the construction of the "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore","isActive":true},{"type":"text","text":", which means the view store will"},{"text":" ","type":"text"},{"type":"text","text":"observe all of state."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To chisel away at the observed state you can provide a closure for that argument that plucks out"},{"type":"text","text":" "},{"type":"text","text":"the state the view needs. In this case the view only needs a single field:"}]},{"code":["WithViewStore(self.store, observe: \\.selectedTab) { viewStore in","  TabView(selection: viewStore.binding(send: { .tabSelected($0) }) {","    \/\/ ...","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"In the future, the view may need access to more state. For example, suppose ","type":"text"},{"code":"Activity.State","type":"codeVoice"},{"text":" holds","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"onto an "},{"code":"unreadCount","type":"codeVoice"},{"type":"text","text":" integer to represent how many new activities you have. There’s no need to"},{"type":"text","text":" "},{"text":"observe ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"all","type":"text"}]},{"type":"text","text":" of "},{"type":"codeVoice","code":"Activity.State"},{"text":" to get access to this one field. You can observe just the one","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"field."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Technically you can do this by mapping your state into a tuple, but because tuples are not"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" you will need to provide an explicit "},{"type":"codeVoice","code":"removeDuplicates"},{"type":"text","text":" argument:"}]},{"code":["WithViewStore(","  self.store, ","  observe: { (selectedTab: $0.selectedTab, unreadActivityCount: $0.activity.unreadCount) },","  removeDuplicates: ==",") { viewStore in ","  TabView(selection: viewStore.binding(get: \\.selectedTab, send: { .tabSelected($0) }) {","    ActivityView(","      store: self.store.scope(state: \\.activity, action: { .activity($0) })","    )","    .tag(AppFeature.Tab.activity)","    .badge(\"\\(viewStore.unreadActivityCount)\")","","    \/\/ ...","  }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Alternatively, and recommended, you can introduce a lightweight, equatable ","type":"text"},{"type":"codeVoice","code":"ViewState"},{"type":"text","text":" struct"},{"type":"text","text":" "},{"text":"nested inside your view whose purpose is to transform the ","type":"text"},{"type":"codeVoice","code":"Store"},{"text":"’s full state into the bare","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"essentials of what the view needs:"}]},{"syntax":"swift","type":"codeListing","code":["struct AppView: View {","  let store: StoreOf<AppFeature>","  ","  struct ViewState: Equatable {","    let selectedTab: AppFeature.Tab","    let unreadActivityCount: Int","    init(state: AppFeature.State) {","      self.selectedTab = state.selectedTab","      self.unreadActivityCount = state.activity.unreadCount","    }","  }","","  var body: some View {","    WithViewStore(self.store, observe: ViewState.init) { viewStore in ","      TabView {","        ActivityView(","          store: self.store","            .scope(state: \\.activity, action: { .activity($0) })","        )","        .badge(\"\\(viewStore.unreadActivityCount)\")","","        \/\/ ...","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"This gives you maximum flexibility in the future for adding new fields to ","type":"text"},{"type":"codeVoice","code":"ViewState"},{"type":"text","text":" without making"},{"type":"text","text":" "},{"type":"text","text":"your view convoluted."}]},{"inlineContent":[{"text":"This technique for reducing view re-computations is most effective towards the root of your app","type":"text"},{"type":"text","text":" "},{"type":"text","text":"hierarchy and least effective towards the leaf nodes of your app. Root features tend to hold lots"},{"type":"text","text":" "},{"text":"of state that its view does not need, such as child features, and leaf features tend to only hold","type":"text"},{"type":"text","text":" "},{"text":"what’s necessary. If you are going to employ this technique you will get the most benefit by","type":"text"},{"type":"text","text":" "},{"type":"text","text":"applying it to views closer to the root. At leaf features and views that need access to most"},{"type":"text","text":" "},{"type":"text","text":"of the state, it is fine to continue using "},{"code":"observe: { $0 }","type":"codeVoice"},{"type":"text","text":" to observe all of the state in the"},{"type":"text","text":" "},{"type":"text","text":"store."}],"type":"paragraph"},{"anchor":"Sharing-logic-with-actions","level":3,"type":"heading","text":"Sharing logic with actions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is a common pattern of using actions to share logic across multiple parts of a reducer."},{"text":" ","type":"text"},{"type":"text","text":"This is an inefficient way to share logic. Sending actions is not as lightweight of an operation"},{"text":" ","type":"text"},{"text":"as, say, calling a method on a class. Actions travel through multiple layers of an application, and","type":"text"},{"type":"text","text":" "},{"text":"at each layer a reducer can intercept and reinterpret the action.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is far better to share logic via simple methods on your "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer"},{"text":" conformance.","type":"text"},{"type":"text","text":" "},{"text":"The helper methods can take ","type":"text"},{"type":"codeVoice","code":"inout State"},{"text":" as an argument if it needs to make mutations, and it","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"can return an "},{"type":"codeVoice","code":"Effect<Action>"},{"text":". This allows you to share logic without incurring the cost","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of sending needless actions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose that there are 3 UI components in your feature such that when any is changed"},{"type":"text","text":" "},{"type":"text","text":"you want to update the corresponding field of state, but then you also want to make some mutations"},{"type":"text","text":" "},{"text":"and execute an effect. That common mutation and effect could be put into its own action and then","type":"text"},{"type":"text","text":" "},{"type":"text","text":"each user action can return an effect that immediately emits that shared action:"}]},{"code":["struct Feature: Reducer {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","","  func reduce(into state: inout State, action: Action) -> Effect<Action> {","    switch action {","    case .buttonTapped:","      state.count += 1","      return .send(.sharedComputation)","","    case .toggleChanged:","      state.isEnabled.toggle()","      return .send(.sharedComputation)","","    case let .textFieldChanged(text):","      state.description = text","      return .send(.sharedComputation)","","    case .sharedComputation:","      \/\/ Some shared work to compute something.","      return .run { send in","        \/\/ A shared effect to compute something","      }","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"This is one way of sharing the logic and effect, but we are now incurring the cost of two actions","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"even though the user performed a single action. That is not going to be as efficient as it would"},{"type":"text","text":" "},{"type":"text","text":"be if only a single action was sent."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Besides just performance concerns, there are two other reasons why you should not follow this"},{"text":" ","type":"text"},{"type":"text","text":"pattern. First, this style of sharing logic is not very flexible. Because the shared logic is"},{"text":" ","type":"text"},{"type":"text","text":"relegated to a separate action it must always be run after the initial logic. But what if"},{"text":" ","type":"text"},{"text":"instead you need to run some shared logic ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"before","type":"text"}]},{"type":"text","text":" the core logic? This style cannot accommodate that."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Second, this style of sharing logic also muddies tests. When you send a user action you have to"},{"type":"text","text":" "},{"text":"further assert on receiving the shared action and assert on how state changed. This bloats tests","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with unnecessary internal details, and the test no longer reads as a script from top-to-bottom of"},{"text":" ","type":"text"},{"type":"text","text":"actions the user is taking in the feature:"}]},{"syntax":"swift","code":["let store = TestStore(initialState: Feature.State()) {","  Feature()","}","","store.send(.buttonTapped) {","  $0.count = 1","}","store.receive(.sharedComputation) {","  \/\/ Assert on shared logic","}","store.send(.toggleChanged) {","  $0.isEnabled = true","}","store.receive(.sharedComputation) {","  \/\/ Assert on shared logic","}","store.send(.textFieldChanged(\"Hello\") {","  $0.description = \"Hello\"","}","store.receive(.sharedComputation) {","  \/\/ Assert on shared logic","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"So, we do not recommend sharing logic in a reducer by having dedicated actions for the logic"},{"text":" ","type":"text"},{"type":"text","text":"and executing synchronous effects."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Instead, we recommend sharing logic with methods defined in your feature’s reducer. The method has"},{"type":"text","text":" "},{"text":"full access to all dependencies, it can take an ","type":"text"},{"code":"inout State","type":"codeVoice"},{"type":"text","text":" if it needs to make mutations to"},{"type":"text","text":" "},{"text":"state, and it can return an ","type":"text"},{"type":"codeVoice","code":"Effect<Action>"},{"type":"text","text":" if it needs to execute effects."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The above example can be refactored like so:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Feature: Reducer {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","","  func reduce(into state: inout State, action: Action) -> Effect<Action> {","    switch action {","    case .buttonTapped:","      state.count += 1","      return self.sharedComputation(state: &state)","","    case .toggleChanged:","      state.isEnabled.toggle()","      return self.sharedComputation(state: &state)","","    case let .textFieldChanged(text):","      state.description = text","      return self.sharedComputation(state: &state)","    }","  }","","  func sharedComputation(state: inout State) -> Effect<Action> {","    \/\/ Some shared work to compute something.","    return .run { send in","      \/\/ A shared effect to compute something","    }","  }","}"]},{"inlineContent":[{"type":"text","text":"This effectively works the same as before, but now when a user action is sent all logic is executed"},{"text":" ","type":"text"},{"type":"text","text":"at once without sending an additional action. This also fixes the other problems we mentioned above."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, if you need to execute the shared logic "},{"inlineContent":[{"type":"text","text":"before"}],"type":"emphasis"},{"text":" the core logic, you can do so easily:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["case .buttonTapped:","  let sharedEffect = self.sharedComputation(state: &state)","  state.count += 1","  return sharedEffect"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"You have complete flexibility to decide how, when and where you want to execute the shared logic.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, tests become more streamlined since you do not have to assert on internal details of"},{"text":" ","type":"text"},{"type":"text","text":"shared actions being sent around. The test reads  like a user script of what the user is doing"},{"type":"text","text":" "},{"type":"text","text":"in the feature:"}]},{"code":["let store = TestStore(initialState: Feature.State()) {","  Feature()","}","","store.send(.buttonTapped) {","  $0.count = 1","  \/\/ Assert on shared logic","}","store.send(.toggleChanged) {","  $0.isEnabled = true","  \/\/ Assert on shared logic","}","store.send(.textFieldChanged(\"Hello\") {","  $0.description = \"Hello\"","  \/\/ Assert on shared logic","}"],"type":"codeListing","syntax":"swift"},{"text":"CPU intensive calculations","type":"heading","anchor":"CPU-intensive-calculations","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reducers are run on the main thread and so they are not appropriate for performing intense CPU"},{"type":"text","text":" "},{"type":"text","text":"work. If you need to perform lots of CPU-bound work, then it is more appropriate to use an"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","isActive":true},{"text":", which will operate in the cooperative thread pool, and then send actions back into","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the system. You should also make sure to perform your CPU intensive work in a cooperative manner by"},{"type":"text","text":" "},{"text":"periodically suspending with ","type":"text"},{"code":"Task.yield()","type":"codeVoice"},{"type":"text","text":" so that you do not block a thread in the cooperative"},{"type":"text","text":" "},{"type":"text","text":"pool for too long."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, instead of performing intense work like this in your reducer:"}]},{"syntax":"swift","code":["case .buttonTapped:","  var result = \/\/ ...","  for value in someLargeCollection {","    \/\/ Some intense computation with value","  }","  state.result = result"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"…you should return an effect to perform that work, sprinkling in some yields every once in awhile,"},{"type":"text","text":" "},{"type":"text","text":"and then delivering the result in an action:"}]},{"type":"codeListing","syntax":"swift","code":["case .buttonTapped:","  return .run { send in","    var result = \/\/ ...","    for (index, value) in someLargeCollection.enumerated() {","      \/\/ Some intense computation with value","","      \/\/ Yield every once in awhile to cooperate in the thread pool.","      if index.isMultiple(of: 1_000) {","        await Task.yield()","      }","    }","    await send(.computationResponse(result))","  }","","case let .computationResponse(result):","  state.result = result"]},{"type":"paragraph","inlineContent":[{"text":"This will keep CPU intense work from being performed in the reducer, and hence not on the main","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"thread."}]},{"level":3,"anchor":"High-frequency-actions","type":"heading","text":"High-frequency actions"},{"type":"paragraph","inlineContent":[{"text":"Sending actions in a Composable Architecture application should not be thought as simple method","type":"text"},{"type":"text","text":" "},{"type":"text","text":"calls that one does with classes, such as "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" conformances. When an action is sent"},{"type":"text","text":" "},{"type":"text","text":"into the system there are multiple layers of features that can intercept and interpret it, and"},{"type":"text","text":" "},{"text":"the resulting state changes can reverberate throughout the entire application.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because of this, sending actions does come with a cost. You should aim to only send “significant”"},{"text":" ","type":"text"},{"text":"actions into the system, that is, actions that cause the execution of important logic and effects","type":"text"},{"text":" ","type":"text"},{"text":"for your application. High-frequency actions, such as sending dozens of actions per second,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"should be avoided unless your application truly needs that volume of actions in order to implement"},{"text":" ","type":"text"},{"type":"text","text":"its logic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there are often times that actions are sent at a high frequency but the reducer doesn’t"},{"type":"text","text":" "},{"type":"text","text":"actually need that volume of information. For example, say you were constructing an effect that"},{"type":"text","text":" "},{"text":"wanted to report its progress back to the system for each step of its work. You could choose to send","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the progress for literally every step:"}]},{"type":"codeListing","syntax":"swift","code":["case .startButtonTapped:","  return .run { send in","    var count = 0","    let max = await self.eventsClient.count()","","    for await event in self.eventsClient.events() {","      defer { count += 1 }","      send(.progress(Double(count) \/ Double(max)))","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, what if the effect required 10,000 steps to finish? Or 100,000? Or more? It would be"},{"type":"text","text":" "},{"text":"immensely wasteful to send 100,000 actions into the system to report a progress value that is only","type":"text"},{"type":"text","text":" "},{"type":"text","text":"going to vary from 0.0 to 1.0."}]},{"inlineContent":[{"text":"Instead, you can choose to report the progress every once in awhile. You can even do the math","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make it so that you report the progress at most 100 times:"}],"type":"paragraph"},{"code":["case .startButtonTapped:","  return .run { send in","    var count = 0","    let max = await self.eventsClient.count()","    let interval = max \/ 100","","    for await event in self.eventsClient.events() {","      defer { count += 1 }","      if count.isMultiple(of: interval) {","        send(.progress(Double(count) \/ Double(max)))","      }","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This greatly reduces the bandwidth of actions being sent into the system so that you are not"},{"type":"text","text":" "},{"text":"incurring unnecessary costs for sending actions.","type":"text"}],"type":"paragraph"},{"level":3,"text":"Compiler performance","type":"heading","anchor":"Compiler-performance"},{"inlineContent":[{"type":"text","text":"In very large SwiftUI applications you may experience degraded compiler performance causing long"},{"type":"text","text":" "},{"type":"text","text":"compile times, and possibly even compiler failures due to “complex expressions.” The"},{"type":"text","text":" "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore","isActive":true,"type":"reference"},{"text":"  helpers that come with the library can exacerbate that problem for very complex","type":"text"},{"type":"text","text":" "},{"text":"views. If you are running into issues using ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore","type":"reference"},{"type":"text","text":", there are two options for fixing"},{"text":" ","type":"text"},{"type":"text","text":"the problem."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"For example, if your view looks like this:","type":"text"}]},{"syntax":"swift","code":["struct FeatureView: View {","  let store: StoreOf<Feature>","","  var body: some View {","    WithViewStore(self.store, observe: { $0 }) { viewStore in","      \/\/ A large, complex view inside here...","    }","  }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"…and you start running into compiler troubles, then you can explicitly specify the type of the","type":"text"},{"text":" ","type":"text"},{"text":"view store in the closure:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["WithViewStore(self.store, observe: { $0 }) { (viewStore: ViewStoreOf<Feature>) in","  \/\/ A large, complex view inside here...","}"]},{"inlineContent":[{"text":"Or you can refactor the view to use an ","type":"text"},{"type":"codeVoice","code":"@ObservedObject"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["struct FeatureView: View {","  let store: StoreOf<Feature>","  @ObservedObject var viewStore: ViewStoreOf<Feature>","","  init(store: StoreOf<Feature>) {","    self.store = store","    self.viewStore = ViewStore(self.store, observe: { $0 })","  }","","  var body: some View {","    \/\/ A large, complex view inside here...","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Both of these options should greatly improve the compiler’s ability to type-check your view."}],"type":"paragraph"}],"kind":"content"}],"kind":"article","metadata":{"modules":[{"name":"ComposableArchitecture"}],"role":"article","title":"Performance","roleHeading":"Article"},"variants":[{"paths":["\/documentation\/composablearchitecture\/performance"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyManagement":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","type":"topic","url":"\/documentation\/composablearchitecture\/dependencymanagement","role":"article","title":"Dependencies","abstract":[{"text":"Learn how to register dependencies with the library so that they can be immediately accessible from","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"any reducer."}],"kind":"article"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/WithViewStore":{"abstract":[{"text":"A view helper that transforms a ","type":"text"},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store","isActive":true},{"type":"text","text":" into a "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore"},{"text":" so that its state can be observed","type":"text"},{"type":"text","text":" "},{"text":"by a view builder.","type":"text"}],"title":"WithViewStore","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"WithViewStore"}],"url":"\/documentation\/composablearchitecture\/withviewstore","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/WithViewStore","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WithViewStore","kind":"identifier"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Effect":{"abstract":[],"title":"Effect","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"role":"symbol","type":"topic","navigatorTitle":[{"text":"Effect","kind":"identifier"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","url":"\/documentation\/composablearchitecture\/effect","kind":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"url":"\/documentation\/composablearchitecture\/testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"title":"Testing","role":"article","type":"topic","kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"},"#Sharing-logic-with-actions":{"url":"#Sharing-logic-with-actions","titleInlineContent":[{"text":"Sharing logic with actions","type":"text"}],"type":"link","identifier":"#Sharing-logic-with-actions","title":"Sharing logic with actions"},"#CPU-intensive-calculations":{"url":"#CPU-intensive-calculations","titleInlineContent":[{"text":"CPU-intensive calculations","type":"text"}],"type":"link","identifier":"#CPU-intensive-calculations","title":"CPU-intensive calculations"},"#High-frequency-actions":{"title":"High-frequency actions","type":"link","url":"#High-frequency-actions","titleInlineContent":[{"text":"High-frequency actions","type":"text"}],"identifier":"#High-frequency-actions"},"doc://ComposableArchitecture/tutorials/MeetComposableArchitecture":{"title":"Meet the Composable Architecture","identifier":"doc:\/\/ComposableArchitecture\/tutorials\/MeetComposableArchitecture","kind":"overview","url":"\/tutorials\/meetcomposablearchitecture","type":"topic","role":"overview","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a"},{"text":" ","type":"text"},{"text":"consistent and understandable way, with composition, testing, and ergonomics in mind. It can be","type":"text"},{"type":"text","text":" "},{"text":"used in SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}]},"#Compiler-performance":{"url":"#Compiler-performance","titleInlineContent":[{"text":"Compiler performance","type":"text"}],"type":"link","identifier":"#Compiler-performance","title":"Compiler performance"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Store":{"abstract":[{"type":"text","text":"A store represents the runtime that powers the application. It is the object that you will pass"},{"type":"text","text":" "},{"type":"text","text":"around to views that need to interact with the application."}],"title":"Store","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Store"}],"url":"\/documentation\/composablearchitecture\/store","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store","role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Store"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","role":"collection","url":"\/documentation\/composablearchitecture","abstract":[{"text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"type":"topic","kind":"symbol","title":"ComposableArchitecture"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/GettingStarted":{"type":"topic","abstract":[{"text":"Learn how to integrate the Composable Architecture into your project and write your first","type":"text"},{"type":"text","text":" "},{"type":"text","text":"application."}],"role":"article","title":"Getting started","url":"\/documentation\/composablearchitecture\/gettingstarted","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","kind":"article"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Navigation":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","role":"collectionGroup","url":"\/documentation\/composablearchitecture\/navigation","abstract":[{"text":"Learn how to use the navigation tools in the library, including how to best model your domains, how","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to integrate features in the reducer and view layers, and how to write tests."}],"type":"topic","kind":"article","title":"Navigation"},"#View-stores":{"type":"link","title":"View stores","identifier":"#View-stores","url":"#View-stores","titleInlineContent":[{"type":"text","text":"View stores"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ViewStore/init(_:observe:)-3ak1y":{"role":"symbol","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"ViewState"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}]},"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore\/init(_:observe:)-3ak1y","title":"init(_:observe:)","kind":"symbol","fragments":[{"text":"init","kind":"identifier"},{"text":"<","kind":"text"},{"text":"State","kind":"genericParameter"},{"text":">(","kind":"text"},{"preciseIdentifier":"s:22ComposableArchitecture5StoreC","text":"Store","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:22ComposableArchitecture9ViewStoreCAASQRzrlE_7observeACyxq_GAA0D0Cyqd__q_G_xqd__ctclufc5StateL_qd__mfp","kind":"typeIdentifier","text":"State"},{"text":", ","kind":"text"},{"text":"ViewAction","kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture9ViewStoreCAASQRzrlE0C6Actionq_mfp"},{"kind":"text","text":">, "},{"text":"observe","kind":"externalParam"},{"kind":"text","text":": ("},{"kind":"externalParam","text":"_"},{"text":" ","kind":"text"},{"text":"state","kind":"internalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:22ComposableArchitecture9ViewStoreCAASQRzrlE_7observeACyxq_GAA0D0Cyqd__q_G_xqd__ctclufc5StateL_qd__mfp","text":"State","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"ViewState","preciseIdentifier":"s:22ComposableArchitecture9ViewStoreCAASQRzrlE0C5Statexmfp","kind":"typeIdentifier"},{"text":")","kind":"text"}],"abstract":[{"text":"Initializes a view store from a store which observes changes to state.","type":"text"}],"url":"\/documentation\/composablearchitecture\/viewstore\/init(_:observe:)-3ak1y","type":"topic"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"role":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"title":"Reducer","abstract":[{"text":"현재 앱의 상태를 주어진 액션을 가지고 어떻게 다음 상태로 변경할 지를 묘사하는 프로토콜. 또한 나중에 Store에 의해 실행되어야 할 ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","isActive":true,"type":"reference"},{"text":"가 무엇인지 묘사하고 있습니다.","type":"text"}],"kind":"symbol","url":"\/documentation\/composablearchitecture\/reducer"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/ViewStore":{"title":"ViewStore","type":"topic","abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"ViewStore"},{"text":" is an object that can observe state changes and send actions. They are most","type":"text"},{"text":" ","type":"text"},{"text":"commonly used in views, such as SwiftUI views, UIView or UIViewController, but they can be used","type":"text"},{"type":"text","text":" "},{"text":"anywhere it makes sense to observe state or send actions.","type":"text"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ViewStore"}],"navigatorTitle":[{"text":"ViewStore","kind":"identifier"}],"url":"\/documentation\/composablearchitecture\/viewstore","role":"symbol","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/ViewStore","kind":"symbol"}}}