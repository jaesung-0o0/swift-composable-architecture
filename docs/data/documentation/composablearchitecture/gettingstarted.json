{"schemaVersion":{"major":0,"patch":0,"minor":3},"kind":"article","sections":[],"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"metadata":{"roleHeading":"Article","modules":[{"name":"ComposableArchitecture"}],"role":"article","title":"Getting started"},"abstract":[{"text":"Learn how to integrate the Composable Architecture into your project and write your first","type":"text"},{"type":"text","text":" "},{"text":"application.","type":"text"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/composablearchitecture\/gettingstarted"]}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Adding the Composable Architecture as a dependency","anchor":"Adding-the-Composable-Architecture-as-a-dependency","level":2},{"inlineContent":[{"text":"To use the Composable Architecture in a SwiftPM project, add it to the dependencies of your","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Package.swift and specify the "},{"code":"ComposableArchitecture","type":"codeVoice"},{"text":" product in any targets that need access to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the library:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let package = Package(","  dependencies: [","    .package(","      url: \"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\",","      from: \"1.0.0\"","    ),","  ],","  targets: [","    .target(","      name: \"<target-name>\",","      dependencies: [","        .product(","          name: \"ComposableArchitecture\",","          package: \"swift-composable-architecture\"","        )","      ]","    )","  ]",")"]},{"type":"heading","text":"Writing your first feature","level":2,"anchor":"Writing-your-first-feature"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To build a feature using the Composable Architecture you define some types and values that model"},{"type":"text","text":" "},{"text":"your domain:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"State"}]},{"type":"text","text":": A type that describes the data your feature needs to perform its logic and render its"},{"type":"text","text":" "},{"text":"UI.","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Action"}],"type":"strong"},{"type":"text","text":": A type that represents all of the actions that can happen in your feature, such as"},{"text":" ","type":"text"},{"text":"user actions, notifications, event sources and more.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Reducer"}],"type":"strong"},{"text":": A function that describes how to evolve the current state of the app to the next","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"state given an action. The reducer is also responsible for returning any effects that should be"},{"type":"text","text":" "},{"text":"run, such as API requests, which can be done by returning an ","type":"text"},{"code":"Effect","type":"codeVoice"},{"text":" value.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Store","type":"text"}],"type":"strong"},{"type":"text","text":": The runtime that actually drives your feature. You send all user actions to the store"},{"text":" ","type":"text"},{"type":"text","text":"so that the store can run the reducer and effects, and you can observe state changes in the"},{"type":"text","text":" "},{"type":"text","text":"store so that you can update UI."}]}]}]},{"inlineContent":[{"type":"text","text":"The benefits of doing this are that you will instantly unlock testability of your feature, and you"},{"type":"text","text":" "},{"text":"will be able to break large, complex features into smaller domains that can be glued together.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"As a basic example, consider a UI that shows a number along with “+” and “−” buttons that increment","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and decrement the number. To make things interesting, suppose there is also a button that when"},{"type":"text","text":" "},{"type":"text","text":"tapped makes an API request to fetch a random fact about that number and then displays the fact in"},{"type":"text","text":" "},{"type":"text","text":"an alert."}]},{"type":"paragraph","inlineContent":[{"text":"To implement this feature we create a new type that will house the domain and behavior of the","type":"text"},{"text":" ","type":"text"},{"text":"feature by conforming to ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"type":"text","text":":"}]},{"code":["struct Feature: Reducer {","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In here we need to define a type for the feature’s state, which consists of an integer for the","type":"text"},{"type":"text","text":" "},{"text":"current count, as well as an optional string that represents the title of the alert we want to show","type":"text"},{"text":" ","type":"text"},{"text":"(optional because ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" represents not showing an alert):","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["struct Feature: Reducer {","  struct State: Equatable {","    var count = 0","    var numberFactAlert: String?","  }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We also need to define a type for the feature’s actions. There are the obvious actions, such as"},{"text":" ","type":"text"},{"type":"text","text":"tapping the decrement button, increment button, or fact button. But there are also some slightly"},{"type":"text","text":" "},{"type":"text","text":"non-obvious ones, such as the action of the user dismissing the alert, and the action that occurs"},{"text":" ","type":"text"},{"text":"when we receive a response from the fact API request:","type":"text"}]},{"syntax":"swift","code":["struct Feature: Reducer {","  struct State: Equatable { \/* ... *\/ }","  enum Action: Equatable {","    case factAlertDismissed","    case decrementButtonTapped","    case incrementButtonTapped","    case numberFactButtonTapped","    case numberFactResponse(String)","  }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"And then we implement the ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer\/reduce(into:action:)-1t2ri","type":"reference"},{"type":"text","text":" method which is responsible for"},{"text":" ","type":"text"},{"type":"text","text":"handling the actual logic and  behavior for the feature. It describes how to change the current"},{"type":"text","text":" "},{"text":"state to the next state, and describes what effects need to be executed. Some actions don’t need to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"execute effects, and they can return "},{"type":"codeVoice","code":".none"},{"text":" to represent that:","type":"text"}]},{"code":["struct Feature: Reducer {","  struct State: Equatable { \/* ... *\/ }","  enum Action: Equatable { \/* ... *\/ }","  ","  func reduce(into state: inout State, action: Action) -> Effect<Action> {","    switch action {","    case .factAlertDismissed:","      state.numberFactAlert = nil","      return .none","","    case .decrementButtonTapped:","      state.count -= 1","      return .none","","    case .incrementButtonTapped:","      state.count += 1","      return .none","","    case .numberFactButtonTapped:","      return .run { [count = state.count] send in","        let (data, _) = try await URLSession.shared.data(","          from: URL(string: \"http:\/\/numbersapi.com\/\\(count)\/trivia\")!","        )","        await send(","          .numberFactResponse(String(decoding: data, as: UTF8.self))","        )","      }","","    case let .numberFactResponse(fact):","      state.numberFactAlert = fact","      return .none","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"And then finally we define the view that displays the feature. It holds onto a "},{"code":"StoreOf<Feature>","type":"codeVoice"},{"text":"","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so that it can observe all changes to the state and re-render, and we can send all user actions to"},{"text":" ","type":"text"},{"type":"text","text":"the store so that state changes. We must also introduce a struct wrapper around the fact alert to"},{"text":" ","type":"text"},{"text":"make it ","type":"text"},{"type":"codeVoice","code":"Identifiable"},{"text":", which the ","type":"text"},{"code":".alert","type":"codeVoice"},{"text":" view modifier requires:","type":"text"}],"type":"paragraph"},{"code":["struct FeatureView: View {","  let store: StoreOf<Feature>","","  var body: some View {","    WithViewStore(self.store, observe: { $0 }) { viewStore in","      VStack {","        HStack {","          Button(\"−\") { viewStore.send(.decrementButtonTapped) }","          Text(\"\\(viewStore.count)\")","          Button(\"+\") { viewStore.send(.incrementButtonTapped) }","        }","","        Button(\"Number fact\") { viewStore.send(.numberFactButtonTapped) }","      }","      .alert(","        item: viewStore.binding(","          get: { $0.numberFactAlert.map(FactAlert.init(title:)) },","          send: .factAlertDismissed","        ),","        content: { Alert(title: Text($0.title)) }","      )","    }","  }","}","","struct FactAlert: Identifiable {","  var title: String","  var id: String { self.title }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"It is also straightforward to have a UIKit controller driven off of this store. You subscribe to the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"store in "},{"code":"viewDidLoad","type":"codeVoice"},{"text":" in order to update the UI and show alerts. The code is a bit longer than the","type":"text"},{"type":"text","text":" "},{"text":"SwiftUI version:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class FeatureViewController: UIViewController {","  let viewStore: ViewStoreOf<Feature>","  var cancellables: Set<AnyCancellable> = []","","  init(store: StoreOf<Feature>) {","    self.viewStore = ViewStore(store, observe: { $0 })","    super.init(nibName: nil, bundle: nil)","  }","","  required init?(coder: NSCoder) {","    fatalError(\"init(coder:) has not been implemented\")","  }","","  override func viewDidLoad() {","    super.viewDidLoad()","","    let countLabel = UILabel()","    let incrementButton = UIButton()","    let decrementButton = UIButton()","    let factButton = UIButton()","","    \/\/ Omitted: Add subviews and set up constraints...","","    self.viewStore.publisher","      .map { \"\\($0.count)\" }","      .assign(to: \\.text, on: countLabel)","      .store(in: &self.cancellables)","","    self.viewStore.publisher.numberFactAlert","      .sink { [weak self] numberFactAlert in","        let alertController = UIAlertController(","          title: numberFactAlert, message: nil, preferredStyle: .alert","        )","        alertController.addAction(","          UIAlertAction(","            title: \"OK\",","            style: .default,","            handler: { _ in self?.viewStore.send(.factAlertDismissed) }","          )","        )","        self?.present(alertController, animated: true, completion: nil)","      }","      .store(in: &self.cancellables)","  }","","  @objc private func incrementButtonTapped() {","    self.viewStore.send(.incrementButtonTapped)","  }","  @objc private func decrementButtonTapped() {","    self.viewStore.send(.decrementButtonTapped)","  }","  @objc private func factButtonTapped() {","    self.viewStore.send(.numberFactButtonTapped)","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we are ready to display this view, for example in the app’s entry point, we can construct a"},{"text":" ","type":"text"},{"text":"store. This can be done by specifying the initial state to start the application in, as well as the","type":"text"},{"type":"text","text":" "},{"text":"reducer that will power the application:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@main","struct MyApp: App {","  var body: some Scene {","    FeatureView(","      store: Store(initialState: Feature.State()) {","        Feature()","      }","    )","  }","}"]},{"inlineContent":[{"type":"text","text":"And that is enough to get something on the screen to play around with. It’s definitely a few more"},{"type":"text","text":" "},{"type":"text","text":"steps than if you were to do this in a vanilla SwiftUI way, but there are a few benefits. It gives"},{"text":" ","type":"text"},{"text":"us a consistent manner to apply state mutations, instead of scattering logic in some observable","type":"text"},{"type":"text","text":" "},{"text":"objects and in various action closures of UI components. It also gives us a concise way of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"expressing side effects. And we can immediately test this logic, including the effects, without"},{"type":"text","text":" "},{"text":"doing much additional work.","type":"text"}],"type":"paragraph"},{"anchor":"Testing-your-feature","text":"Testing your feature","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"To test use a ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","type":"reference"},{"text":", which can be created with the same information as the ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store"},{"type":"text","text":", but it"},{"text":" ","type":"text"},{"type":"text","text":"does extra work to allow you to assert how your feature evolves as actions are sent:"}]},{"syntax":"swift","type":"codeListing","code":["@MainActor","func testFeature() async {","  let store = TestStore(initialState: Feature.State()) {","    Feature()","  }","}"]},{"inlineContent":[{"text":"Once the test store is created we can use it to make an assertion of an entire user flow of steps.","type":"text"},{"type":"text","text":" "},{"text":"Each step of the way we need to prove that state changed how we expect. For example, we can simulate","type":"text"},{"text":" ","type":"text"},{"text":"the user flow of tapping on the increment and decrement buttons:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Test that tapping on the increment\/decrement buttons changes the count","await store.send(.incrementButtonTapped) {","  $0.count = 1","}","await store.send(.decrementButtonTapped) {","  $0.count = 0","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, if a step causes an effect to be executed, which feeds data back into the store, we must"},{"type":"text","text":" "},{"text":"assert on that. For example, if we simulate the user tapping on the fact button we expect to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"receive a fact response back with the fact, which then causes the alert to show:"}]},{"syntax":"swift","code":["await store.send(.numberFactButtonTapped)","","await store.receive(.numberFactResponse(\"???\")) {","  $0.numberFactAlert = \"???\"","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, how do we know what fact is going to be sent back to us?"}]},{"inlineContent":[{"type":"text","text":"Currently our reducer is using an effect that reaches out into the real world to hit an API server,"},{"text":" ","type":"text"},{"type":"text","text":"and that means we have no way to control its behavior. We are at the whims of our internet"},{"type":"text","text":" "},{"type":"text","text":"connectivity and the availability of the API server in order to write this test."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It would be better for this dependency to be passed to the reducer so that we can use a live"},{"type":"text","text":" "},{"type":"text","text":"dependency when running the application on a device, but use a mocked dependency for tests. We"},{"text":" ","type":"text"},{"type":"text","text":"can do this by adding a property to the "},{"code":"Feature","type":"codeVoice"},{"text":" reducer:","type":"text"}]},{"syntax":"swift","code":["struct Feature: Reducer {","  let numberFact: (Int) async throws -> String","  \/\/ ...","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Then we can use it in the ","type":"text"},{"type":"codeVoice","code":"reduce"},{"text":" implementation:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["case .numberFactButtonTapped:","  return .run { [count = state.count] send in","    let fact = try await self.numberFact(count)","    await send(.numberFactResponse(fact))","  }"]},{"inlineContent":[{"type":"text","text":"And in the entry point of the application we can provide a version of the dependency that actually"},{"text":" ","type":"text"},{"text":"interacts with the real world API server:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["@main","struct MyApp: App {","  var body: some Scene {","    FeatureView(","      store: Store(initialState: Feature.State()) {","        Feature(","          numberFact: { number in","            let (data, _) = try await URLSession.shared.data(","              from: .init(string: \"http:\/\/numbersapi.com\/\\(number)\")!","            )","            return String(decoding: data, as: UTF8.self)","          }","        )","      }","    )","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But in tests we can use a mock dependency that immediately returns a deterministic, predictable fact:"}]},{"syntax":"swift","type":"codeListing","code":["@MainActor","func testFeature() async {","  let store = TestStore(initialState: Feature.State()) {","    Feature(numberFact: { \"\\($0) is a good number Brent\" })","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With that little bit of upfront work we can finish the test by simulating the user tapping on the"},{"type":"text","text":" "},{"type":"text","text":"fact button, receiving the response from the dependency to trigger the alert, and then dismissing"},{"type":"text","text":" "},{"text":"the alert:","type":"text"}]},{"type":"codeListing","code":["await store.send(.numberFactButtonTapped)","","await store.receive(.numberFactResponse(\"0 is a good number Brent\")) {","  $0.numberFactAlert = \"0 is a good number Brent\"","}","","await store.send(.factAlertDismissed) {","  $0.numberFactAlert = nil","}"],"syntax":"swift"},{"inlineContent":[{"text":"We can also improve the ergonomics of using the ","type":"text"},{"type":"codeVoice","code":"numberFact"},{"text":" dependency in our application. Over","type":"text"},{"type":"text","text":" "},{"type":"text","text":"time the application may evolve into many features, and some of those features may also want access"},{"text":" ","type":"text"},{"text":"to ","type":"text"},{"type":"codeVoice","code":"numberFact"},{"type":"text","text":", and explicitly passing it through all layers can get annoying. There is a process"},{"type":"text","text":" "},{"text":"you can follow to “register” dependencies with the library, making them instantly available to any","type":"text"},{"type":"text","text":" "},{"text":"layer in the application.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can start by wrapping the number fact functionality in a new type:"}]},{"type":"codeListing","code":["struct NumberFactClient {","  var fetch: (Int) async throws -> String","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"And then registering that type with the dependency management system, which is quite similar to"},{"type":"text","text":" "},{"text":"how SwiftUI’s environment values works, except you specify the live implementation of the","type":"text"},{"text":" ","type":"text"},{"text":"dependency to be used by default:","type":"text"}],"type":"paragraph"},{"code":["private enum NumberFactClientKey: DependencyKey {","  static let liveValue = NumberFactClient(","    fetch: { number in","      let (data, _) = try await URLSession.shared.data(","        from: .init(string: \"http:\/\/numbersapi.com\/\\(number)\")!","      )","      return String(decoding: data, as: UTF8.self)","    }","  )","}","","extension DependencyValues {","  var numberFact: NumberFactClient {","    get { self[NumberFactClientKey.self] }","    set { self[NumberFactClientKey.self] = newValue }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"With that little bit of upfront work done you can instantly start making use of the dependency in","type":"text"},{"type":"text","text":" "},{"type":"text","text":"any feature:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Feature: Reducer {","  struct State { \/* ... *\/ }","  enum Action { \/* ... *\/ }","  @Dependency(\\.numberFact) var numberFact","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"text":"This code works exactly as it did before, but you no longer have to explicitly pass the dependency","type":"text"},{"type":"text","text":" "},{"text":"when constructing the feature’s reducer. When running the app in previews, the simulator or on a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"device, the live dependency will be provided to the reducer, and in tests the test dependency will"},{"type":"text","text":" "},{"type":"text","text":"be provided."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This means the entry point to the application no longer needs to construct dependencies:"}]},{"type":"codeListing","syntax":"swift","code":["@main","struct MyApp: App {","  var body: some Scene {","    FeatureView(","      store: Store(initialState: Feature.State()) {","        Feature()","      }","    )","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"And the test store can be constructed without specifying any dependencies, but you can still","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"override any dependency you need to for the purpose of the test:"}]},{"syntax":"swift","type":"codeListing","code":["let store = TestStore(initialState: Feature.State()) {","  Feature()","} withDependencies: {","  $0.numberFact.fetch = { \"\\($0) is a good number Brent\" }","}","","await store.send(.numberFactButtonTapped)","await store.receive(.numberFactResponse(\"0 is a good number Brent\")) {","  $0.numberFactAlert = \"0 is a good number Brent\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That is the basics of building and testing a feature in the Composable Architecture. There are"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"a lot","type":"text"}]},{"text":" more things to be explored, such as ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement"},{"type":"text","text":", "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","isActive":true,"type":"reference"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwiftConcurrency","isActive":true},{"type":"text","text":" and more about "},{"type":"reference","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","isActive":true},{"type":"text","text":". Also, the "},{"identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples","type":"reference","isActive":true},{"type":"text","text":" directory has"},{"type":"text","text":" "},{"type":"text","text":"a bunch of projects to explore to see more advanced usages."}]}]}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","interfaceLanguage":"swift"},"seeAlsoSections":[{"identifiers":["doc:\/\/ComposableArchitecture\/tutorials\/MeetComposableArchitecture","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance"],"generated":true,"title":"Essentials"}],"references":{"doc://ComposableArchitecture/tutorials/MeetComposableArchitecture":{"title":"Meet the Composable Architecture","identifier":"doc:\/\/ComposableArchitecture\/tutorials\/MeetComposableArchitecture","kind":"overview","url":"\/tutorials\/meetcomposablearchitecture","type":"topic","role":"overview","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a"},{"text":" ","type":"text"},{"text":"consistent and understandable way, with composition, testing, and ergonomics in mind. It can be","type":"text"},{"type":"text","text":" "},{"text":"used in SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Navigation":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","role":"collectionGroup","url":"\/documentation\/composablearchitecture\/navigation","abstract":[{"text":"Learn how to use the navigation tools in the library, including how to best model your domains, how","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to integrate features in the reducer and view layers, and how to write tests."}],"type":"topic","kind":"article","title":"Navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","role":"collection","url":"\/documentation\/composablearchitecture","abstract":[{"text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS).","type":"text"}],"type":"topic","kind":"symbol","title":"ComposableArchitecture"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Store":{"abstract":[{"type":"text","text":"A store represents the runtime that powers the application. It is the object that you will pass"},{"type":"text","text":" "},{"type":"text","text":"around to views that need to interact with the application."}],"title":"Store","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Store"}],"url":"\/documentation\/composablearchitecture\/store","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Store","role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Store"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"url":"\/documentation\/composablearchitecture\/testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"title":"Testing","role":"article","type":"topic","kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"},"https://github.com/pointfreeco/swift-composable-architecture/tree/main/Examples":{"identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples","title":"Examples","titleInlineContent":[{"text":"Examples","type":"text"}],"url":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples","type":"link"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer/reduce(into:action:)-1t2ri":{"role":"symbol","abstract":[{"text":"리듀서의 현재 상태를 다음 상태로 변경합니다.","type":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer\/reduce(into:action:)-1t2ri","kind":"symbol","url":"\/documentation\/composablearchitecture\/reducer\/reduce(into:action:)-1t2ri","title":"reduce(into:action:)","required":true,"fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"reduce"},{"text":"(","kind":"text"},{"text":"into","kind":"externalParam"},{"kind":"text","text":": "},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"preciseIdentifier":"s:22ComposableArchitecture7ReducerP5StateQa","kind":"typeIdentifier","text":"State"},{"text":", ","kind":"text"},{"text":"action","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture7ReducerP6ActionQa","text":"Action"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:22ComposableArchitecture6EffectV","text":"Effect"},{"kind":"text","text":"<"},{"text":"Action","preciseIdentifier":"s:22ComposableArchitecture7ReducerP6ActionQa","kind":"typeIdentifier"},{"text":">","kind":"text"}],"type":"topic","defaultImplementations":1},"doc://ComposableArchitecture/documentation/ComposableArchitecture/SwiftConcurrency":{"title":"Adopting Swift concurrency","type":"topic","abstract":[{"text":"Learn how to write safe, concurrent effects using Swift’s structured concurrency.","type":"text"}],"kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SwiftConcurrency","role":"article","url":"\/documentation\/composablearchitecture\/swiftconcurrency"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"role":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"title":"Reducer","abstract":[{"text":"현재 앱의 상태를 주어진 액션을 가지고 어떻게 다음 상태로 변경할 지를 묘사하는 프로토콜. 또한 나중에 Store에 의해 실행되어야 할 ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","isActive":true,"type":"reference"},{"text":"가 무엇인지 묘사하고 있습니다.","type":"text"}],"kind":"symbol","url":"\/documentation\/composablearchitecture\/reducer"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyManagement":{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","type":"topic","url":"\/documentation\/composablearchitecture\/dependencymanagement","role":"article","title":"Dependencies","abstract":[{"text":"Learn how to register dependencies with the library so that they can be immediately accessible from","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"any reducer."}],"kind":"article"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Performance":{"abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"url":"\/documentation\/composablearchitecture\/performance","type":"topic","role":"article","kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","title":"Performance"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"url":"\/documentation\/composablearchitecture\/teststore","abstract":[{"text":"A testable runtime for a reducer.","type":"text"}],"kind":"symbol","navigatorTitle":[{"text":"TestStore","kind":"identifier"}],"title":"TestStore","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"TestStore","kind":"identifier"}]},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Effect":{"abstract":[],"title":"Effect","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Effect"}],"role":"symbol","type":"topic","navigatorTitle":[{"text":"Effect","kind":"identifier"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","url":"\/documentation\/composablearchitecture\/effect","kind":"symbol"}}}